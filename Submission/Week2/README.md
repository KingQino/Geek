### 第二周作业提交

* 任务1在上一级目录的GeekLab项目中
* 任务6在上一级目录中的demo项目中，需要在命令行中运行`java com.example.demo.nio.HttpServer01`开启服务端进程，再测试。



* 任务4：对于GC和堆内存的总结
  * 背景：Java作为一种跨平台的编程语言，是由于其在不同的操作系统上构建了一种抽象的可移植的“操作系统”JVM，与C语言最大的不同是Java提供了一套自动回收内存的机制，其中垃圾回收一般指的是对堆内存的回收，堆内存中存放着所有对象、对象成员、类定义和静态变量。
  * 堆内存由年轻代（其又分为Eden区和survivor区）和老年代构成，基于分代假设，大部分新分配到年轻代的对象用过就扔，但是也有一些对象会存活很长时间，这些对象就会晋升到老年代。随着不停地向堆内存中分配对象，会优先触发minor GC (Young GC)扔掉不用的垃圾释放内存；在经过多次minor GC后，不少对象晋升到了老年代，当老年代的使用率达到一定阈值后即会触发major GC（Full GC）。
  * 各种GC
    * 串行GC：串行 GC 对年轻代使用mark-copy(标记-复制) 算法，对老年代使用 mark-sweep-compact(标记-清除- 整理)算法，两个阶段都会触发STW，适合单核CPU使用，是早期的GC方式，效率低下。
    * 并行GC：与串行GC所做的事情一样，但是并行操作利用了多核CPU的特性，多个CPU内核会同时参与垃圾回收，这比串行效率更高，提高了吞吐量。
    * 【补充-并行与并发】
      * 并行指多个进程在做同一件事
      * 并发指，这多个进程中，有的进程在做事情A，同时有的进程在做事情B
    * CMS GC（Mostly Concurrent Mark and Sweep Garbage Collector）：对年轻代采用并行 STW 方式的 mark-copy (标记-复制)算法，对老年代主要使用并发 mark-sweep ( 标记-清除)算法。也就是说，在做major GC时，一般并不触发STW，垃圾回收与应用线程的工作同时进行。
    * G1 GC：将 STW 停顿的时间和分布，变成可预期且可配置的。首先，堆不再分成年轻代和老年代，而是划分为多个(通常是 2048个)可以存放对象的小块堆区域(smaller heap regions)。 每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来 就是年轻代，所有的 Old 区拼在一起那就是老年代。这样划分之后，使得G1不必每次都去收集整个堆空间，而是以增量的方式来进行处理: 每次只处理一部分内存块，称为此次 GC 的回收集(collection set)。每次 GC 暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块。G1 的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是: 垃圾最多的小块会被优先收集。这也是 G1 名称 的由来。
    * ZGC/Shenandoah GC：实验型的GC

